PARSER_BEGIN(Karloff)
import java.io.*;

class Karloff{
  Main main;
  ArrayList <Func> funcao;
  Karloff(Main m,ArrayList <Func> f) {this.main = m; this.funcao.f;}
}

class Main{
  ArrayList <VarDecl> varDecl;
  ArrayList <Comando> seqComandos;
  Main(ArrayList <VarDecl> varDecl, ArrayList <Comando> seqComandos) {this.varDecl = varDecl; this.comando = c;}
}

class VarDecl{
  String variavel;
  Tipo tipo;
  varDecl(String v,Tipo t){this.variavel = v; this.tipo = t;}
}

// Tipo
class Tipo{}
class Int extends Tipo{}
class Bool extends Tipo{}

// SeqComandos
class SeqComandos{
  ArrayList <Comando> comando;
  SeqComandos(ArrayList <Comando> comando){this.comando = comando};
}

// Comando
class Comando{}
class Atribuicao extends Comando{
  String variavel;
  Exp exp;
  Atribuicao(String v,Exp e){this.variavel = var; this.e = exp;}
}

class ChamadaDeFuncao extends Comando{
  String func;
  ArrayList <Exp> argumentos;
  ChamadaDeFuncao(String f, ArrayList <Exp> args){this.func = f; this.argumentos = args;}
}

class Parenteses extends Comando{
    String p;
    ArrayList <Exp> listaExp;
    Parenteses(String p, ArrayList <Exp> listExp){ this.p = p; this.listaExp=listExp;}    
}

class If extends Comando{
  Exp expBool;
  ArrayList <Comando> comandos;
  If(Exp e,ArrayList <Comando> c){this.expBool = e; this.comandos = c;}
}

class While extends Comando{
  Exp exp;
  ArrayList <Comando> comandos;  
  While(Exp e, ArrayList <Comando> c){this.exp = e; this.comandos = c;}
}

class Repeat extends Comando{
  ArrayList <Comando> comandos; 
  Exp exp; 
  Repeat(ArrayList <Comando> c,Exp e){this.comandos=c;this.exp = e;}
}

class Return extends Comando{
  Exp e;
  Return(Exp e){this.e = e;}
}

class SystemOutput extends Comando{
   Exp e;
   SystemOutput(Exp e){this.e = e;}
}

// Exp
class Exp{}

// Exp op Exp
class OperacaoExp extends Exp{
   Exp e1;
   String op;
   Exp e2;
   OperacaoExp(Exp e1,Exp e2,String op){this.e1=e1;this.op=op;this.e2=e2;}
}

// Fator
class Fator extends Exp{}

// Fator Id
class FatorId extends Fator{
   String id;
   FatorId(String id){this.id = id;}
}
// Fator Parenteses
class FatorParenteses extends Fator{
   String p;
   ArrayList <Exp> listaExp;
   FatorParenteses(String p,ArrayList <Exp> listaExp){this.p=p;this.listaExp=listaExp;}
}
// Fator NumLiteral
class FatorNumLiteral extends Fator{
   String numLit;
   FatorNumLiteral(String numLit){this.numLit=numLit;}
}

// Fator Tipo
class FatorTipo extends Fator{
   Tipo tipo;
   FatorTipo(Tipo tipo){this.tipo=tipo;}
}

//ListaExp
class ListaExp{
   Exp e;
   listaExp(Exp e){this.e=e;}
}

//Func
class Func{
   Tipo tipo;
   String id;
   ArrayList <ListaArg> listaArg;
   ArrayList <VarDecl> varDecl;
   ArrayList <Comando> seqComandos;
   Func(Tipo tipo,String id,ArrayList <ListaArg> listaArg,ArrayList <VarDecl> varDecl,ArrayList <Comando> seqComandos)
   {this.tipo=tipo;this.id=id;this.listaArg=ListaArg;this.varDecl=varDecl;this.seqComandos=seqComandos;}
}

//ListaArg
class ListaArg{
   Tipo tipo;
   String id;
   ListaArg(Tipo tipo,String id){this.tipo=tipo;this.id=id}
}


public class Karloff {

  public static void main(String args[]) throws Exception {
    // abrir o arquivo passado por linha
    // de comando contendo o código em Karloff:
    FileInputStream fs = new FileInputStream(new File(args[0]));

    // Instanciar o parser da linguagem Karloff passando 
    // como argumento o arquivo contendo o código
    // Karloff a ser processado:
    Karloff parser = new Karloff(fs);

    // Chamar a primeira regra do parser que irá
    // analisar o código e devolver a árvore sintática
    ArvoreKarloff arvore = parser.Karloff();

    // Passar a árvore para o pretty printer, ou gerador de código
    pprint(arvore);
  }
  
  public static void pprint(ArvoreKarloff prog){
      pMain();


  }
  
  public static void pMain(Main main){
      System.out.print("void ");
      System.out.print("main ");
      System.out.print("{ ");
      
      


      System.out.print("}");
  }

 

  

  public static void geraCodigo(ArvoreKarloff prog){

  }
}

PARSER_END(Karloff)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
  <MAIN: "main">
| <ACHAVES: "{">
| <FCHAVES: "}">
| <NVAR: "newVar">
| <PVIRG: ";">
| <VIRG: ",">
| <APAR: "(">
| <FPAR: ")">
| <INT: "int">
| <BOOL: "bool">
| <IF: "if">
| <THEN: "then">
| <TRUE: "true">
| <FALSE: "false">
| <WHILE: "while">
| <REPEAT: "repeat">
| <RETURN: "return">
| <UNTIL: "until">
| <SO: "System.output">
| <ATRIB: "=">
| <FUNC: "func">
| <VOID: "void">
|<TOKEN_LITERAL: ((["0"-"9"])+) (("."(["0"-"9"])+)? ("E"("+"|"-")? (["0"-"9"])+))?>
|<TOKEN_ID: <LETRAS> (<LETRAS>|<DIGITOS>)*((<LETRAS>|<DIGITOS>)+)* ("_")*>
}

TOKEN :
{
 <OP: ("+" | "-" | "*" | "/" | "&&" | "||" | "<" | ">" | "==")>
|<ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"])*>
|<#DIGITOS:(["0"-"9"]) >
|<#LETRAS: ["a"-"z","A"-"Z"]>
}

Karloff Karloff () :
{Main main; ArrayList <Func> f = new ArrayList<Func>();}
{ 
  main = Main()
  (f = Func())?
  <EOF> 
  {return new Karloff(main,f);}
}


Main Main ():
{ArrayList <VarDecl> varDecl; ArrayList <Comando> seqComandos;}
{
  <VOID> <MAIN> <ACHAVES> 
   varDecl = VarDecl()
   seqComandos = SeqComandos()
 <FCHAVES>

 {return new Main(varDecl,seqComandos);}
}
	
VarDecl VarDecl(): 
{ArrayList<VarDecl> varD = new ArrayList<VarDecl>(); String v;Tipo t;}
{
   ( v = <NVAR> t = Tipo() <TOKEN_ID> <PVIRG> {varD.add(new varDecl(v,t))})* 
   {return VarD}
}

Tipo Tipo(): 
{Tipo t = null}
{
   ( t = <INT> {t = new Int();}) | ( t = <BOOL> = {t = new Bool();})
   {return t;}
}

ArrayList<Comando> SeqComandos():
{ArrayList <Comando> comando = new ArrayList<Comando>(); Comando c}
{
   ( c = Comando() {comando.add(c);})*
   {return comando;} 
}

/////

void Comando(): {}
{
   <TOKEN_ID> Comando1()
|  <IF> <APAR> Exp() <FPAR> <THEN> <ACHAVES> SeqComandos() <FCHAVES> <PVIRG>
|  <WHILE> <APAR> Exp() <FPAR> <ACHAVES> SeqComandos() <FCHAVES> <PVIRG>
|  <REPEAT> <ACHAVES> SeqComandos() <FCHAVES> <UNTIL> <APAR> Exp() <FPAR> <PVIRG>
|  <RETURN> Exp() <PVIRG>
|  <SO> <APAR> Exp() <FPAR> <PVIRG>
}

//Utilizado para eliminar alternativa que comecam com o mesmo simbolo
void Comando1(): {}
{
  <ATRIB>Exp()<PVIRG>|<APAR>(ListaExp())?<FPAR><PVIRG>
}

void Exp(): {}
{
   <APAR> Exp() <OP> Exp() <FPAR> | Fator()
}

void Fator(): {}
{
   <TOKEN_ID> Fator1() | <TOKEN_LITERAL> | <FALSE> | <TRUE>
}

//Utilizado para eliminar alternativa que começam com o mesmo simbolo
void Fator1(): {}
{
  (<APAR> ListaExp() <FPAR>)?
}

void ListaExp(): {}
{
   Exp() ListaExp1()  
}

//Utilizado para eliminar recursão a esquerda
void ListaExp1(): {}
{
   (<VIRG> Exp() ListaExp1())?  
}

void Func(): {}
{
   (<FUNC> Tipo() <TOKEN_ID> <APAR> (ListaArg())? <FPAR> <ACHAVES> VarDecl() SeqComandos() <FCHAVES>)+
}

void ListaArg(): {}
{
   Tipo() <TOKEN_ID> (ListaArg1())
}

//Utilizado para eliminar recursão a esquerda
void ListaArg1(): {}
{
   (<VIRG> Tipo() <TOKEN_ID> ListaArg1())?
}
