PARSER_BEGIN(Karloff)
import java.io.*;
public class Karloff {

  public static void main(String args[]) throws ParseException,IOException {
    
    Karloff parser = new Karloff(new FileInputStream(args[0]));
    parser.Karloff();
  }

}

PARSER_END(Karloff)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
  <MAIN: "main">
| <ACHAVES: "{">
| <FCHAVES: "}">
| <NVAR: "newVar">
| <PVIRG: ";">
| <VIRG: ",">
| <APAR: "(">
| <FPAR: ")">
| <INT: "int">
| <BOOL: "bool">
| <IF: "if">
| <THEN: "then">
| <TRUE: "true">
| <FALSE: "false">
| <WHILE: "while">
| <REPEAT: "repeat">
| <RETURN: "return">
| <UNTIL: "until">
| <SO: "System.output">
| <ATRIB: "=">
| <SUBL: "_"> 
| <FUNC: "func">
| <VOID: "void">
}

TOKEN :
{
 <OP: ("+" | "-" | "*" | "/" | "&&" | "||" | "<" | ">" | "==")>
|<ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"])*>
|<DIGITOS:(["0"-"9"]) >
|<LETRAS: ["a"-"z","A"-"Z"]>
|<PONTO: ".">
|<E: "E"> 
|<MAIS: "+">
|<MENOS: "-">
}

void LetraouDigito(): {}
{
  (<LETRAS>|<DIGITOS>)*
}

void FinalSublinhado():{}
{
   <SUBL>(LetraouDigito())+ 
}

void TOKEN_id(): {}
{
  <LETRAS> (LetraouDigito())* (FinalSublinhado())*
}

void TOKEN_numLiteral(): {}
{
  Digitos() FracaoOp() ExpoenteOp()
}

void Digitos(): {}
{
  (<DIGITOS>)+
}


void ExpoenteOp(): {}
{
  (<E> (<MAIS>|<MENOS>)? Digitos())? 
}

void FracaoOp(): {}
{
  (<PONTO> Digitos())?
}


void Karloff () :
{}
{ 

  Main() 
//Func()?
  <EOF> 
}
	
void VarDecl(): {}
{
   (<NVAR> Tipo() <ID> <PVIRG>)*
}

void Tipo(): {}
{
   (<INT>|<BOOL>)
}

void SeqComandos(): {}
{
   (Comando())* 
}

void Comando(): {}
{
   <ID> <ATRIB> Exp() <PVIRG>
|  <IF> <APAR> Exp() <FPAR> <THEN> <ACHAVES> SeqComandos() <FCHAVES> <PVIRG>
|  <WHILE> <APAR> Exp() <FPAR> <ACHAVES> SeqComandos() <FCHAVES> <PVIRG>
|  <REPEAT> <ACHAVES> SeqComandos() <FCHAVES> <UNTIL> <APAR> Exp() <FPAR> <PVIRG>
|  <RETURN> Exp() <PVIRG>
|  <SO> <APAR> Exp() <FPAR> <PVIRG>
}

void Exp(): {}
{
	 <APAR> Exp() <OP> Exp <FPAR> | Fator()
}

void Fator(): {}
{
   <ID> | <ID> <APAR> ListaExp() <FPAR> | TOKEN_numliteral() | <FALSE> | <TRUE>
}

void ListaExp(): {}
{
   Exp() ListaExp1()  
}

//Utilizado para eliminar recursão a esquerda
void ListaExp1(): {}
{
   (<VIRG> Exp() ListaExp1())?  
}

voif Func(): {}
{
   (<FUNC> Tipo() <ID> <APAR> (ListaArg())? <FPAR> <ACHAVES> VarDecl() SeqComandos() <FCHAVES>)+
}

void ListaArg(): {}
{
	 Tipo() <ID> ListaArg1()
}

//Utilizado para eliminar recursão a esquerda
void ListaArg1(){}
{
	  <VIRG> Tipo() <ID> ListaArg1())?
}


void Main ():
{}
{
 <VOID><MAIN> <ACHAVES> 
 
 // VarDecl()
 // SeqComandos()

 <FCHAVES>

}





